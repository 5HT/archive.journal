Pure Sigma

ĞšÑ‚Ğ¾-Ñ‚Ğ¾ Ğ½Ğ° Ğ³Ğ¸Ñ‚Ñ‚ĞµÑ€ ĞºĞ°Ğ½Ğ°Ğ»Ğµ Ğ¿Ñ€Ğ¾ÑĞ¸Ğ» Ğ³Ğ¾Ğ´ Ğ½Ğ°Ğ·Ğ°Ğ´, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ĞµĞ¼Ñƒ Ğ¡Ğ¸Ğ³Ğ¼Ñƒ Ğ·Ğ°ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ»Ğ¸ Ğ² Ñ‡Ğ¸ÑÑ‚Ñ‹Ñ… 
Ñ„ÑƒĞ½ĞºÑ†Ğ¸ÑÑ…. Ğ¯ Ñ‚Ğ¾Ğ³Ğ´Ğ° Ğ½Ğµ ÑĞ¼Ğ¾Ğ³ ÑÑ‚Ğ¾ ÑĞ´ĞµĞ»Ğ°Ñ‚ÑŒ, Ğ½Ğ¾ Ğ²Ğ¾Ñ‚ Ğ½ĞµĞ´Ğ°Ğ²Ğ½Ğ¾ Ñ„Ğ¾Ñ€Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ» Ğ´Ğ¾Ğ¼Ğ°ÑˆĞºĞ¸ Ğ¸ 
Ñ€ĞµÑˆĞ¸Ğ» Ğ¿Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ‚Ğ°ĞºĞ¾Ğµ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ² ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğµ Ğ´Ğ¾Ğ¼Ğ°ÑˆĞºĞ¸. ĞœĞ½Ğµ Ğ²Ñ€Ğ¾Ğ´Ğµ Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ğ»Ğ¸, Ñ‡Ñ‚Ğ¾ 
ĞĞ»ÑŒÑ‚ĞµĞ½ĞºĞ¸Ñ€Ñ… Ğ³Ğ´Ğµ-Ñ‚Ğ¾ Ğ¿Ğ¸ÑĞ°Ğ» Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾ Ğ½ĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¸Ğ»Ğ¸ Ğ¿Ğ¾ ĞºÑ€Ğ°Ğ¹Ğ½ĞµĞ¹ Ğ¼ĞµÑ€Ğµ ÑÑ‚Ğ¾ Ğ½Ğµ Ğ¾Ğ±Ğ»Ğ°Ğ´Ğ°ĞµÑ‚ 
Ğ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ñ…Ğ¾Ñ€Ğ¾ÑˆĞ¸Ğ¼Ğ¸ Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ñ…Ğ°Ñ€Ğ°ĞºÑ‚ĞµÑ€Ğ¸ÑÑ‚Ğ¸ĞºĞ°Ğ¼Ğ¸.

-- Sigma/@
   \ (A: *)
-> \ (P: A -> *)
-> \ (n: A)
-> \/ (Exists: *)
-> \/ (Intro: A -> P n -> Exists)
-> Exists

-- Sigma/Intro
   \ (A: *)
-> \ (P: A -> *)
-> \ (x: A)
-> \ (y: P x)
-> \ (Exists: *)
-> \ (Intro: A -> P x -> Exists)
-> Intro x y

-- Sigma/fst
   \ (A: *)
-> \ (B: A -> *)
-> \ (n: A)
-> \ (S: #Sigma/@ A B n)
-> S A ( \(x: A) -> \(_: B n) -> x )

-- Sigma/snd
   \ (A: *)
-> \ (B: A -> *)
-> \ (n: A)
-> \ (S: #Sigma/@ A B n)
-> S (B n) ( \(_: A) -> \(y: B n) -> y )

-- Sigma/test
-- P: nat -> U = (\(_:nat) -> list nat)
-- mk nat P n5 nil
#Sigma/Intro #Nat/@
             (\(n: #Nat/@) -> #List/@ #Nat/@)
             #Nat/Five
             (#List/replicate #Nat/@ #Nat/Five #Nat/Zero)

-- Sigma/test.fst
-- fst nat P zero test
#Sigma/fst #Nat/@
           (\(n: #Nat/@) -> #List/@ #Nat/@)
           #Nat/Zero
           #Sigma/test

-- Sigma/test.snd
-- snd nat P zero test
#Sigma/snd #Nat/@
           (\(n: #Nat/@) -> #List/@ #Nat/@)
           #Nat/Zero
           #Sigma/test


Ğ’ Ñ‚ĞµÑÑ‚Ğ°Ñ… ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ°Ğ¿Ğ»Ğ° (nat, list nat) = (5, [0,0,0,0,0]) Ğ¸ Ğ²Ğ·ÑÑ‚Ğ¸Ğµ Ñƒ Ğ½ĞµĞ³Ğ¾ 
Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¹ Ğ¸ Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ Ğ¿Ñ€Ğ¾ĞµĞºÑ†Ğ¸Ğ¸:

1> om:fst(om:erase(om:norm(om:a("#Sigma/test.snd"))))
== om:fst(om:erase(om:norm(om:a("(#List/replicate #Nat/@ #Nat/Five 
#Nat/Zero)")))).
true
2> om:fst(om:erase(om:norm(om:a("#Sigma/test.fst"))))
== om:fst(om:erase(om:norm(om:a("#Nat/Five")))).
true
3> om:type(om:type(om:a("#Sigma/snd"))).
{star,1}
4> om:type(om:type(om:a("#Sigma/fst"))).
{star,1}


Ğ¢Ñ€ÑĞº Ğ·Ğ°ĞºĞ»ÑÑ‡Ğ°ĞµÑ‚ÑÑ Ğ² Ğ¿Ñ€Ğ¾Ñ‚Ğ°ÑĞºĞ¸Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ³Ğ¾ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ° Ğ² Ğ±Ğ°Ğ·Ñƒ, Ğ²ÑĞµ Ñ€Ğ°Ğ²Ğ½Ğ¾ ĞºĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€ 
Ğ¾Ğ´Ğ¸Ğ½ Ğ¸ Ğ¾Ğ½ Ğ¶Ğµ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ ĞµĞ³Ğ¾. Ğ¢.Ğµ. ĞºĞ»Ğ°ÑÑĞ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ¸Ğ½Ğ´ÑƒĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğµ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ

data Sigma (A: Type) (P: A -> Type): Type
   = (intro: (x:A) (y:P x) -> Sigma A P)


ÑĞ¼ĞµĞ½ÑĞµÑ‚ÑÑ Ğ½Ğ° ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞµ:

data Sigma (A: Type) (P: A -> Type) (x:A): Type
   = (intro: (y:P x) -> Sigma A P)


ĞĞ°Ğ²ĞµÑ€Ğ½ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ğ½Ğ°Ñ‡Ğ½ÑƒÑ‚ÑÑ ĞºĞ°Ğº Ñ pred, ĞºĞ¾Ğ³Ğ´Ğ° Ğ¿Ñ€Ğ¸Ğ´ĞµÑ‚ÑÑ Ğ·Ğ°ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ N-Ñ‚Ğ°Ğ¿Ğ» Ğ¸Ğ· ÑĞ¸Ğ³Ğ¼ 
Ğ¸ Ğ¿ĞµÑ€ĞµĞ½Ğ¾ÑĞ¸Ñ‚ÑŒ Ğ²ÑĞµ ĞºÑ€Ğ¾Ğ¼Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ Ğ² Ğ±Ğ°Ğ·Ñƒ, Ğ½Ğ¾ Ñ‚Ğ¾Ğ¶Ğµ Ğ²Ñ€Ğ¾Ğ´Ğµ Ğ²ÑĞµ Ğ·Ğ°ĞºĞ¾Ğ½Ğ½Ğ¾. 
Ğ•Ğ´Ğ¸Ğ½ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾Ğµ Ğº Ñ‡ĞµĞ¼Ñƒ Ñ‚ÑƒÑ‚ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ñ€ĞµĞ´ÑŠÑĞ²Ğ¸Ñ‚ÑŒ Ğ¿Ñ€ĞµÑ‚ĞµĞ½Ğ·Ğ¸Ğ¸ â€” ÑÑ‚Ğ¾ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ 
Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ Ğ¿ÑƒÑÑ‚Ñ‹ÑˆĞºĞ° #Nat/Zero ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¿ĞµÑ€ĞµĞ´Ğ°ĞµÑ‚ÑÑ Ğ² Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ°Ñ… Ğ² ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğµ (x:A) Ğ¿Ñ€Ğ¸ 
Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğµ ÑĞ»Ğ¸Ğ¼Ğ¸Ğ½Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ², Ğ¾Ğ½ Ğ½ÑƒĞ¶ĞµĞ½ Ğ´Ğ»Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ñ‚Ğ¸Ğ¿Ğ¾Ğ², Ğ½Ğ¾ ĞºĞ°Ğº Ğ²Ğ¸Ğ´Ğ½Ğ¾ Ğ¸Ğ· Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ°, 
ÑĞºÑÑ‚Ñ€Ğ°ĞºÑ‚ÑÑ‚ÑÑ Ğ¸Ğ· ÑĞºĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ñ‚Ğ°Ğ¿Ğ»Ğ° #Sigma/Intro Ğ½Ğ°ÑÑ‚Ğ¾ÑÑ‰Ğ¸Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ (fst 
test = 5 Ğ¸ snd test = [0,0,0,0,0]). Ğ”Ñ€ÑƒĞ³Ğ¸Ğ¼Ğ¸ ÑĞ»Ğ¾Ğ²Ğ°Ğ¼Ğ¸ ÑÑ‚Ğ¾ Ğ¾Ğ·Ğ½Ğ°Ñ‡Ğ°ĞµÑ‚ Ñ‡Ñ‚Ğ¾ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ 
ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ñ‚Ğ¸Ğ¿Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿Ğ°Ñ€Ñ‹ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ ĞºĞ°Ğº Ğ¼Ğ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼ ÑÑ‚ÑĞ³Ğ¸Ğ²Ğ°ĞµĞ¼Ñ‹Ğ¼ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½ÑÑ‚Ğ²Ğ¾Ğ¼, Ñ‡Ñ‚Ğ¾ Ğ² 
Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ğµ Ğ² Ğ´ÑƒÑ…Ğµ Ğ¡Ğ¸Ğ³Ğ¼Ñ‹ Ğ¸ ĞºĞ²Ğ°Ğ½Ñ‚Ğ¾Ñ€Ğ° ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ. Ğ§Ñ‚Ğ¾ Ğ´ÑƒĞ¼Ğ°ÑÑ‚ Ğ¿Ğ¾ ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ¿Ğ¾Ğ²Ğ¾Ğ´Ñƒ 
Ñ‚Ğ¸Ğ¿Ğ¾Ğ²Ñ‹Ğµ Ñ‚ĞµĞ¾Ñ€ĞµÑ‚Ğ¸ĞºĞ¸?

P.S. ĞœĞ¾Ğ´ĞµĞ»ÑŒ Ğ² cubicaltt, Ğ´Ğ»Ñ Ñ‚ĞµÑ…, ĞºÑ‚Ğ¾ Ğ½Ğµ Ğ´Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ ĞĞ¼.

module puresigma where
import nat
import list

P: nat -> U = (\(_:nat) -> list nat)
sig (A:U)(P:A->U)(x:A): U = (e:U)->(i:A->P x->e)->e
mk  (A:U)(P:A->U)(x:A)(y:P x)(e:U)(i:A->P x->e):e=i x y
fst (A:U)(P:A->U)(x:A)(s:sig A P x):A=s A(\(z:A)(y:P x)->z)
snd (A:U)(P:A->U)(x:A)(s:sig A P x):P x=s(P x)(\(z:A)(y:P x)->y)

test: sig nat P n5 = mk nat P n5 nil
test_pr1: nat = fst nat P zero test
test_pr2: list nat = snd nat P zero test

> test_pr2
EVAL: nil
> test_pr1
EVAL: suc (suc (suc (suc (suc zero))))

Ğ¢ÑƒÑ‚ Ğ¼Ğ½Ğµ Ğ¿Ğ¾Ğ´ÑĞºĞ°Ğ·Ñ‹Ğ²Ğ°ÑÑ‚, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¸ÑĞ°Ğ» Thorsten Altenkirch:

Ok, when we think of homogenous tuples AxA then this can also be understood as 
a function 2 -> A. This also works for heterogenous tuples like AxB using 
dependent functions Pi x:2.if x then A else B. However the next logical step is 
Sigma x:A.B x, which have no good representations as functions (unless we 
accept very dependent functions which in my mind goes against the spirit of 
type theory). For this reason it seems to me that the generalisation from -> to 
Pi and from x to Sigma is the primary one, and the fact that tuples can be 
represented as functions is secondary.

ĞŸĞ¾Ğ·Ğ²Ğ¾Ğ»Ñ ÑĞµĞ±Ğµ Ğ½Ğµ ÑĞ¾Ğ³Ğ»Ğ°ÑĞ¸Ñ‚ÑŒÑÑ Ñ Ğ¢Ğ¾Ñ€ÑÑ‚ĞµĞ½Ğ¾Ğ¼,ĞĞ»ÑŒÑ‚ĞµĞ½ĞºĞ¸Ñ€Ñ…Ğ¾Ğ¼: Ğ½Ğ° Ğ¼Ğ¾Ğ¹ Ğ²Ğ·Ğ³Ğ»ÑĞ´, Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾ 
Ğ§ĞµÑ€Ñ‡ ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ¸ Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ ÑĞºÑ€Ñ‹Ñ‚ÑƒÑ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ½ÑƒÑ ÑÑ‚Ñ€ĞºÑƒÑ‚ÑƒÑ€Ñƒ Ñ‚ĞµĞ¾Ñ€Ğ¸Ğ¸ Ñ‚Ğ¸Ğ¿Ğ¾Ğ² Ğ¾Ğ±Ğ½Ğ°Ğ¶Ğ°Ñ 
ĞµĞµ ÑĞ°Ğ¼Ğ°Ğ½Ñ‚Ğ¸ĞºÑƒ, Ğ¾Ğ½Ğ° Ğ½Ğ¸ ĞºĞ°Ğº Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¸Ğ´Ñ‚Ğ¸ Ğ² Ñ€Ğ°Ğ·Ñ€ĞµĞ· Ğ´ÑƒÑ…Ğ° Ñ‚ĞµÑ‚Ğ¾Ñ€Ğ¸Ğ¸ Ñ‚Ğ¸Ğ¿Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¼ ĞºĞ°Ğº 
Ñ€Ğ°Ğ· Ğ¸ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ñ‚ĞµĞ¾Ñ€Ğ¸Ñ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¹.

Ğ¡ÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ°Ñ Ğ±Ğ¾Ğ»ĞµĞµ Ğ¾Ğ±Ñ‰Ğ°Ñ ÑĞ²ÑĞ·ÑŒ Ğ¼ĞµĞ¶Ğ´Ñƒ ĞŸĞ¸ Ğ¸ Ğ¡Ğ¸Ğ³Ğ¼Ğ¾Ğ¹. Ğ¡Ğ¸Ğ³Ğ¼Ñƒ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ 
Ğ¸Ğ½Ñ‚ĞµÑ€Ğ¿Ñ€ĞµÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞºĞ°Ğº Ñ‚Ğ¾Ñ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½ÑÑ‚Ğ²Ğ¾ Ñ€Ğ°ÑÑĞ»Ğ¾ĞµĞ½Ğ¸Ñ B -> A Ğ½Ğ°Ğ´ A. Ğ“Ğ´Ğµ 
Ñ€Ğ°ÑÑĞ»Ğ¾ĞµĞ½Ğ¸Ğµ â€” ÑÑ‚Ğ¾ Ñ‚ĞµÑ€Ğ¼
section (A B : U) (p : A -> B) (s : B -> A) : U = (y : B) -> Path B (p (s y)) y
Ğ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ ĞŸĞ¸ Ğ¸Ğ»Ğ¸ Ğ»ÑĞ¼Ğ±Ğ´Ñ‹ â€” ÑÑ‚Ğ¾ ÑĞµÑ‡ĞµĞ½Ğ¸Ñ Ñ‚Ñ€Ğ¸Ğ²Ğ¸Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ñ€Ğ°ÑÑĞ»Ğ¾ĞµĞ½Ğ¸Ñ A -> A x B. 
Ğ¡Ğ¸Ğ¼Ğ¼ĞµÑ‚Ñ€Ğ¸Ñ‡Ğ½Ğ¾Ğ¹ Ñ„ÑƒĞ½ĞºÑ†Ğ¸ĞµĞ¹ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ñ€ĞµÑ‚Ñ€Ğ°ĞºÑ‚:
retract (A B : U) (f : A -> B) (g : B -> A) : U = (a : A) -> Path A (g (f a)) a
ĞĞµ Ğ¼Ğ¾Ğ³Ñƒ Ğº ÑĞ¾Ğ¶Ğ°Ğ»ĞµĞ½Ğ¸Ñ (Ğ¿Ğ¾ĞºĞ°) Ğ¿Ğ¾Ğ½ÑÑ‚ÑŒ, ĞºĞ°Ğº ÑƒÑÑ‚Ñ€Ğ¾ĞµĞ½Ñ‹ Ğ¹Ğ¾Ğ³Ğ¸ Ğ“Ñ€Ğ¾Ñ‚ĞµĞ½Ğ´Ğ¸ĞºĞ°, Ğ½Ğ¾ ÑÑ‚Ğ¾ 
ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ ÑĞ²ÑĞ·Ğ¸ ĞŸĞ¸ Ğ¸ Ğ¡Ğ¸Ğ³Ğ¼Ñ‹ Ğ¿Ğ¾Ğ¼Ğ¾ĞµĞ¼Ñƒ Ğ´Ğ²Ğµ Ğ¸Ğ· Ğ½Ğ¸Ñ… Ğ¸ ĞµÑÑ‚ÑŒ.

ĞĞ°Ğ´Ğ¾ Ğ¿ĞµÑ€ĞµĞ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ğ½Ğ° ĞºÑƒĞ±Ğ¸ĞºĞ°Ğ», ĞºÑ‚Ğ¾ Ğ²Ğ¾Ğ·ÑŒĞ¼ĞµÑ‚ÑÑ?
Prerequisites:

_â‹”_ : âˆ€ {a b} â†’ Set a â†’ Set b â†’ Set (a âŠ” b)
_â‹”_ A B = A â†’ B

_âŠ—_ : âˆ€ {a b} â†’ Set a â†’ Set b â†’ Set (a âŠ” b)
_âŠ—_ A B = A Ã— B

âˆ«â†“ : âˆ€ {a b} {X : Set a} â†’ (X â†’ X â†’ Set b) â†’ Set (a âŠ” b)
âˆ«â†“ {X = X} P = âˆ€ {x} â†’ P x x

âˆ«â†‘ : âˆ€ {a b} {X : Set a} â†’ (X â†’ X â†’ Set b) â†’ Set (a âŠ” b)
âˆ«â†‘ {X = X} P = âˆ [ x âˆ¶ X ] P x x
Ğ›ĞµĞ²Ğ¾Ğµ Ğ¸ Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğµ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ñ ĞšĞ°Ğ½Ğ°:
Ran : âˆ€ {x c v u p} {ğ”µ : Set x} {ğ”  : Set c} {ğ”³ : Set v}
  â†’ (ğ’¸ : ğ”  â†’ ğ”  â†’ Set u)
  â†’ (_â‹”_ : Set u â†’ ğ”³ â†’ Set p)
  â†’ (G : ğ”µ â†’ ğ” )
  â†’ (H : ğ”µ â†’ ğ”³)
  â†’ (ğ”  â†’ Set (p âŠ” x)) = ğ’¸ _â‹”_ G H A = âˆ«â†“ Î» x y â†’ ğ’¸ A (G x) â‹” H y

Lan : âˆ€ {x c v u p} {ğ”µ : Set x} {ğ”  : Set c} {ğ”³ : Set v}
  â†’ (ğ’¸ : ğ”  â†’ ğ”  â†’ Set u)
  â†’ (_âŠ—_ : ğ”³ â†’ Set u â†’ Set p)
  â†’ (G : ğ”µ â†’ ğ” )
  â†’ (H : ğ”µ â†’ ğ”³)
  â†’ (ğ”  â†’ Set (p âŠ” x)) = ğ’¸ _âŠ—_ G H A = âˆ«â†‘ Î» x y â†’ H x âŠ— ğ’¸ (G y) A


ĞŸĞ¾ ÑĞ¸Ğ³Ğ½Ğ°Ñ‚ÑƒÑ€Ğµ Ğ²Ğ¸Ğ´Ğ½Ğ¾, Ñ‡Ñ‚Ğ¾ ĞŸĞ¸ Ğ¸ Ğ¡Ğ¸Ğ³Ğ¼Ğ° â€” ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½ÑÑ‚Ğ²Ğ°.
Sigma: âˆ€ {x y} {X : Set x} {Y : Set y} â†’ (X â†’ Y) â†’ ğ’« x X â†’ ğ’« (x âŠ” y) Y = Ran 
_â‰¡_ _â‹”_ f

Pi:    âˆ€ {x y} {X : Set x} {Y : Set y} â†’ (X â†’ Y) â†’ ğ’« x X â†’ ğ’« (x âŠ” y) Y = Lan 
_â‰¡_ _âŠ—_ f


___________
[1]. Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ñ ĞšĞ°Ğ½Ğ° Ğ‘Ğ°Ñ€Ñ‚Ğ¾ÑˆĞ° 
https://henrychern.files.wordpress.com/2017/10/27.pdf
TAGS (EDIT) #list, #nat, #sigma, cs, groupoid infinity, om
