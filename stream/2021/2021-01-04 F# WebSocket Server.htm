<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>2021-01-04</title>
    <link rel="stylesheet" href="https://n2o.dev/blank.css" />
    <link rel="stylesheet" href="../../journal.css" />
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>TOP</a>
    <a href='#'>2021-01-04</a>
</nav>
<main>
    <section>
        <h3>F# WebSocket Server</h3>

        <h4>Аннотация</h4>

        <p>Идея писать веб-сервера и веб-фреймворки на всех языках у меня возникла с тех пор,
           когда я понял, что то что я сделал для Erlang: направление фреймворков
           для предприятий под общим брендом N2O, а сейчас в виде <a href="https://n2o.dev">N2O.DEV</a>;
           вполне применимо и для других языков и платформ. В этой статье представлена версия
           вебсокет-сервера для языка программирования F# &mdash; <a href="https://ws.erp.uno">WS.ERP.UNO</a>.</p>

        <h4>Предисловие</h4>

        <p><b>Haskell</b>. Первый эксперимент был совершен Андреем Мельниковым в виде порта для Хаскеля:
           <a href="https://github.com/nponeccop/n2o.hs">N2O.HS</a>, позже более полную версию с N2O и NITRO
           с экзестенциальными сигнатурами сделал Марат Хафизов, который управляет
           Github организацией <a href="https://github.com/o3">O3</a> и
           сайтом <a href="https://o3.click">o3.click</a>. Мне совершенно непонятно,
           почему ни один хаскель программист, которые вроде как должны восхищаться
           минимализмом, не идет по этому пути, а обычно ищет правды в таких фреймворках
           как UrWeb, IHP, UnisonWeb. На мой взгляд &mdash; всё это переусложненные штуки.</p>

        <p><b>Standard ML</b>. Также в академических целях, Марах Хафизов сделал порт связки
           веб-сервера N2O и веб-фреймворка NITRO на язык Standard ML
           (обе главные версии SML/NJ и MLton) &mdash; эта работа представлена Github
           организацией <a href="https://github.com/o1">O1</a>. Это тот язык, который
           я считаю уместно преподавать как первый академический язык
           программирования (до знакомства с промышленными языками Erlang, F#, Haskell).</p>

        <p><b>Lean</b>. Для закрепления своей идеи и более четкой и точной ее артикуляции я
           попросил <a href="https://github.com/forked-from-1kasper">Siegmentation Fault</a> сделать
           порт на еще более формальный язык программирования, математический прувер Lean 4.
           Эта версия связки веб-сервера N2O и веб-фреймворка NITRO представлена Github
           организацией <a href="https://github.com/o89">O89</a> и сразу двумя
           сайтами: <a href="https://lean4.dev">lean4.dev</a> и <a href="https://bum.pm">bum.pm</a>.
           Последний представляет собой пакетный менеджер написанный на Lean 4. Эти организации
           и эти проекты залайкал Леонардо де Мура, автор Lean и Z3, чему мы безмерно рады.</p>

        <h4>Идиоматический веб-сервер на F#</h4>

        <p>Критерии идиоматичности могут каждым восприниматься по разному, но в основном
           это означаем минимум прелюдий и максимум сути, так или иначе основная мантра всех
           минималистов в общем и N2O инфраструктуры в частности. Так в современные критерии
           идиоматичности веб-сервера для языка F# я бы выделил следующее: 1) использование
           системных классов System.Net.WebSockets, которые уже предоставляют буферизированные
           енкодер и декодер фремов стандарта RFC 6455; 2) сервер должен быть построен на Async
           компютейшинал экспрешинах; 3) для управления асинхронными потоками
           выполнения должен использоваться MailboxProcessor, а не самописная
           система воркеров, которая хоть и поможет выжать последнее из F# (у меня
           получилось 14 миллионов сообщений в секунду), но не продемонстрирует сути, так как будет
           девиацией в сторону рантаймов; 4) Использование классов TcpListener и TcpClient,
           NetworkStream. Больше ни чем не разрешается пользоваться!</p>

        <h4>Что почитать перед написанием?</h4>

        <p>Немного погуглив, я понял что интернету нехватает статьи, которая описывает историю
           понятия асинхронных вычислений и вычислительных выражений, которые в народе
           известны по ключевым словам <b>async/await</b>. Вижу статью, которая называется
           <b>"Survey of Brief Async history"</b>, в которой будет показана ретроспектива Async
           технологии:</p>

        <p>1) LISP call/cc 1968;<br>
           2) Erlang 1986;<br>
           3) Concurrent ML 1998;<br>
           4) Perl IO:Async 2007;<br>
           5) F# Async 2010<br>
           6) C#/PHP Async 2012<br>
           7) Python async 2015<br>
           8) ECMAScript async 2017<br>
           9) и так далее.</p>

        <p>Основополагающей статье по F# async я бы назвал F# Async Guid Лео Городинского,
           <a href="https://JET.COM">JET.COM</a>. Основной презентацией по F# Async я бы назвал
           доклад Дона Сайма на митапе в Лондоне &mdash;
          <a href="https://www.erlang-factory.com/upload/presentations/270/FSharp-ef.pdf">Some F#
           for the Erlang programmer</a>. Основной книгой, которую я бы порекомендовал
           тоже полистать &mdash; это <b>"Expert F# 4.0"</b> автора языка Дона Сайма. Вооружившись этими документами
           и <a href="https://gist.github.com/sgtz/95e7db96fd0858a28b5a/stargazers">этим
           Gist сниппетом</a> я ухал во Львов писать самый идиоматичный вебсокет-сервер.</p>

        <h4>Витрина</h4>

        <p>Как обычно принятно в бектрекинг системах, прологах и декларативных языках, будем
           двигаться с конца, а именно с интерфейса который мы хотим получить. Хочется, чтобы
           ЭХО-сервер представлял собой функцию <b>id</b>.</p>

        <figure>
        <code>
  open N2O
  module Program =
    [<EntryPoint>]
    let main _ =
        let mutable ret = 0
        try Stream.protocol &lt;- fun x -> x
            use disposing = Server.start "0.0.0.0" 1900
            System.Threading.Thread.Sleep -1
        with exn ->
            printfn "EXIT: %s" exn.Message
            ret &lt;- 1
        ret
        </code>
        </figure>

        <h4>Сервер</h4>

    </section>
</main>
<footer>Namdak Tonpa <span class="heart">&nbsp;❤&nbsp;</span> 2009—2021</footer>
</body>
</html>
