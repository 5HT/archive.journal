<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Namdak Tonpa" />
    <title>2019-10-09</title>
    <link rel="stylesheet" href="https://n2o.dev/blank.css" />
    <link rel="stylesheet" href="https://tonpa.guru/journal.css" />
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>TOP</a>
    <a href='#'>2019-10-09</a>
</nav>
<main>
  <article>
    <section>
     <h3>NITRO елемент #comboLookup</h3>

      <p><b>Дизайн та імплементація контрольних елементів</b>.
         Покажемо на прикладі <b>#comboLookup</b> як створювати контрольні елементи
         у середовищі N2O NITRO.</p>

     <h4>Дизайн</h4>

     <p><b>Скафолдінг контрольного елементу</b></p>
     <p>Контрол стандартно постачається у трьох файлах:</p>
     <p>— comboLookup.css<br/>
        — comboLookup.js<br/>
        — comboLookup.erl або comboLookup.ex<br/></p>
     <p><b>Розробка компонент</b></p>
     <p>Контрол структурується як: 1) поле вводу для пошуту по зовнішньому віддаленому сервісу;
     2) контейнер для результатів пошуку; 3) елементи результатів пошуку (насправді
     спеціалізовани редактори вводу відповідних елементів списку результатів пошуку);
     4) управляючі елементи: кнопка пошуку та кнопка вібірни наступної порції даних
     через серверний курсор пошуку.</p>
     <figure><img src="ent/comboLookup.png" width="400"/></figure>
     <p>Кожна компонента 1—4 повинна бути окремим DOM елементом,
        а елементи результатів пошуку (4) повинні мати свої Erlang або Elixir визначення,
        так як ці форми відображають безпосередньо дані пошукових фідів,
        і таким чином є обов'язковими.</p>
     <p><b>Розробка протоколу</b></p>
     <p>За основу пропонується взять наступний протокол управління контрольним елементом:</p>
     <p>— <b>#comboInit{name=[]}</b>, де name — ім'я курсору. Серверний код ціього повідомлення
             повинен буде визначити по імені курсору певний фід в базі даних аби
             переконатися що курсор існує, для подальшого пошуку по ньому. В JavaScript
             частині IO повідомлення NITRO протоколу повинно бути записаний код
             зберігання курсору в localStorage, який буде унікальним на рівні пристроїв.
             При відсилці <b>comboInit</b> повинен містити поточне збережене значення з localStorage.<br/><br/>
        — <b>#comboSearch{prefix=[]}</b>, де prefix — це введені користувачем символи
             для повнотекстового або довільного пошуку по фіду на сервері. Серверний код
             цього повідомлення повинен виконати lookup по базі даних та пересунути курсор
             на кількіть елементів у первій видачі.<br/><br/>
        — <b>#comboNext{pos=[],count=[]}</b>, повторний запит на видачу результатів
             попередньо виконаного пошуку, або просто видача даних з пересуненням курсору
             на кількість елементів виданій у цьому запиту.</b></p>
     <p>Як і кожне повідомлення протоколу NITRO, результати обробки протоколу контрольних
        елементів повинні бути IO повідомленнями <b>{io,Code,Data}</b>, де <b>Code</b> — це
        JavaScript з відрендереними на сервері HTML та JavaScript частинами форми,
        які вбудовують результати видачі у контейнер (2). Тому у тілі функції протоколу
        контрольного елементу ми формуємо actions (які будуть скинуті в сокет
        протколом NITRO в повідомленні IO) за допомогою <b>nitro:wire</b>,
        або іншої функції з побічними ефектами які генерують JavaScript
        в контексті Erlang процесу.</p>

     <h4>Іплементація</h4>

     <p><b>Бінд та налаштування івентінгу</b></p>
     <figure><code>
     </code></figure>
     <p><b>Імплементація протоколу</b></p>
     <figure><code>
     </code></figure>
     <p><b>Розробка клієнтської частини</b></p>
     <figure><code>
     </code></figure>
     <p><b>Специфікація на стилі</b></p>

     <h4>Додаток 1</h4>

     <p>Перелік функцій на стороні JavaScript для реалізаціі
        мінімального клієнта N2O NITRO протоколу:</p>

     <p>token() — поточний токен сесії<br/>
        qi(name) — DOM елемент по існуючому id<br/>
        qs(name) — пошук DOM елементу<br/>
        qn(name) — створення нового DOM елементу<br/>
        is(x, num, name)<br/>
        co(name) — отримання cookies (застаріло)<br/>
        querySource(name) — отримання преформатованої змінної поля value<br/>
        validateSources(list) — провалідувати поле value для списку елементів<br/>
        N2O_start() — створення веб-сокет каналу<br/>
        $bert — реалізація бінарного берт протоколу на JavaScript<br/>
        $io — IO протокол (евалуатор та помилки)<br/>
        $file — FTP протокол (трансфер великих файлів до 100ГБ)<br/>
        $ws — вебсокет транспорт<br/>
        transports — транспорти<br/>
        protos — протоколи<br/>
        </p>

        <br/>
        <hr/>
        <br/>

     <p>— <a href="https://n2o.dev/deps/nitro/man/ua/index.html">NITRO</a> — Загальна інформація про веб-фреймворк NITRO<br/>
        — <a href="https://n2o.dev/deps/n2o/man/ua/index.html">N2O</a> — Опис контейнера протоколів та сервісів N2O<br/>
        — <a href="https://n2o.dev/deps/n2o/man/ua/n2o_nitro.htm">N2O NITRO</a> — Опис протоколу веб-фреймворку<br/>
        — <a href="https://n2o.dev/deps/n2o/man/ua/bert.js.htm">BERT.JS</a> — Опис бінарного протоколу<br/></p>
    </section>
  </article>
</main>
<footer>Конституция <span class="heart"> ❤ </span> SYNRC</footer>
</body>
</html>
