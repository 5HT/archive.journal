<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Namdak Tonpa" />
    <title>2019-09-26</title>
    <link rel="stylesheet" href="https://n2o.dev/blank.css" />
    <link rel="stylesheet" href="https://tonpa.guru/journal.css" />
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>TOP</a>
    <a href='#'>2019-09-26</a>
</nav>
<main>
  <article>
    <section>
     <h3>Планировщик бизнес-процессов</h3>

      <p>Для реализации в следующей версии BPE 5.0 примитивов #gateway и #subProcess (ISO/IEC-19510),
         нам понадобится что-то вроде скедулера, а также реализация древовидной истории процесса.
         Текущая версия BPE, как вы знаете, однопоточная, это означает, что для реализации паралельных
         вычислений вы должны явно стартовать другой процесс из определенной задачи, и он уже будет
         управлятся напрямую своим Erlang-процессом, но тоже иметь свою линейную историю.
         Связывать и ждать завешение вам тоже нужно самому и изобретать для этого свой протокол.
         Почему Сохацкий сразу не ебанул ISO c субпроцессами? Потому что хотел показать, что
         и без гейтвеев можно строить системы, показать то что важно, но теперь пришла пора
         полностью реализовать стандарт. Поэтому сразу --- новые рекорды и алгоритм.</p>

     <h4>#gateway</h4>
      <p>Согласно стандарту гейтвеи #gateway в общем случае это мультиплексоры или демультиплексоры
         с разной логикой: "И" (паралельное выполнение),
         "ИЛИ" (однопоточное условное выполнение, условный оператор), а также для редюсеров:
         ждать "ВСЕ" ребра, "ОДНО" или определённое "ПОДМНОЖЕСТВО" рёбер.</p>

     <h4>#subProcess</h4>
      <p>#subProcess же просто обычная задача, которая создает дополнительную группировку,
         в реальности все будет происходить в том же Эрланг процессе, новый эрланг процесс создаваться не будет.</p>

     <h4>Алгоритм</h4>
      <p>Начнем с примера. Представим себе граф Х, в которм вершины B, C, F являются
         паралельным многопоточным сплитом (fork), а вершины G и J являются паралельными
         демультимплексорами, которые ожидают завершение всех входящих вершин (join),
         т.е. их наличие в истории процесса.</p>
      <figure><code> 
             E ----------- H
          4 /       7     /
           C             / 8
     1  2 / \ 5  9      /
  A ---- B   F --- I   /           [  Граф X ]
        3 \   \ 11  \ 10
           D - G --- J ----- K
             6    12     13
      </code></figure>
      <p>NOTE: обратите внимание, что в общем случае у процесса может быть несколько точек входа,
         это означает, что на начальном этапе в планировщие уже присутствует несколько
         паралельных потоков выполнения которые будут квантоваться линейной
         последовательностью событий самого Erlang-процесса.</p>
      <p>Итак, в примере у нас старт с А(1), она же будет первым потоком планировщика,
         адреса других потоков планировщика (в разное время):
         A/B(2,3), A/B/C(4,5), A/B/C/F(9,11), т.е. кортежи составленые из разветвлений.</p>
      <p>Первый шаг, начинаем процесс и выполняем ребро 1, которе нам дает единственный
         поток выполнения А, событие #beginEvent. Сразу перед вторым шагом делаем следующее:
         видим, что ребро 1 нас привело в состояние B, из которого исходят паралельные ребра 2 и 3
         поэтому мы их еще до выполнения второго шага, ложим в планировщик, а ребро 1 и поток
         выполнения А удаляем, так как после этой точки уже будут другие потоки управления.
         На втором шаге у нас два потока выполнения: A/B(2) и A/B(3).
         Выбираем первый попавшийся и делаем шаг по этому ребру, например, A/B(2). Тут, поскольку
         стоит опять гейтвей, мы еще перед выполнением третьего шаго изменяем потоки планировщика,
         и, точно также как на первом ребре, мы удаляем A/B(2) поток и на его место создаем два потока
         A/B/C(4) и A/B/C(5), поток A/B(3) при этом не трогаем.</p>
      <p>Внутри на каждом шаге мы храним курсоры потоков выполнения в циклическом массиве
         и крутим его индекс на каждом шаге, одновременно обновляя курсоры.
         В приведенном линеаризированом трейсе
         покажем как упаковывается древовидная история процесса.</p>
      <p>Шаг 1: BEGIN, [BEGIN->1], 1<br/>
         Шаг 2: 1, [1->2,3], 1<br/>
         Шаг 3: 2, [2->4,5;3], 2<br/>
         Шаг 4: 3, [4;5;3->6], 1<br/>
         Шаг 5: 4, [4->7;5;6], 2<br/>
         Шаг 6: 5, [7;5->9,11;6], 4<br/>
         Шаг 7: 6, [7;9;11;6->12], 1<br/>
         Шаг 8: 7, [7->8;9;11;12], 2<br/>
         Шаг 9: 9, [8;9->10;11;12], 3<br/>
         Шаг 10: 11, [8;11->10;12], 3<br/>
         Шаг 11: 12, [8;10;12->13], 1<br/>
         Шаг 12: 8, [10;13], 1<br/>
         Шаг 13: 10, [13], 1<br/>
         Шаг 14: 13, [13->END], 0<br/>
         Шаг 15: END, [], 0<br/>
         </p>
       <p>В этом CSV-логе первый элемент -- это номер выполнившегося ребра,
          второй -- это состояние планировщика (список его потоков разделенных точкой с запятой),
          третий -- это указатель на текущий поток выполнения.</p>
       <p>На join элементах нужно гарантировать, что входщие ребра
          необходимые для пропихивания процесса вперед, находятся в
          истории процесса (это делается за 1 get по индексу истории процесса для каждого входящего ребра).
          К счатью в нашем примере алгоритм линеаризировал автоматически правильную последовательность без
          рейсов и блокировок.</p>
       <p>При наличие циклов в графе, трейс процеса потенциально может иметь бесконечную длину.
          Алгоритм позволяет создать план выполнения даже бесконечных процессов
          при отсутствии свободных переменных в логике (функции) процесса, в этом случае недетерминизм.</p>
    </section>
  </article>
</main>
<footer>Namdak Tonpa <span class="heart"> ❤ </span> 2019</footer>
</body>
</html>
