<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>2022-01-17</title>
    <link rel="stylesheet" href="https://n2o.dev/blank.css" />
    <link rel="stylesheet" href="../../journal.css" />
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>TOP</a>
    <a href='#'>2022-01-17</a>
</nav>
<main>
    <section>
        <h3>Anders: верификатор математики</h3>

        <p>Верификатор математики Anders все лишь один из трех гомотопических пруверов Групоид Инфинити.
           Другие два &mdash; это: 1) верификатор под названием Hurricane системы типов HoTT-I,
           которая используется в теорем прувере JetBrains Arend, а также 2) верификатор
           под названием Castle Bravo авторской системы типов HoTT-∂. В отличии от Anders,
           обе системы HoTT-I и HoTT-∂ обладают инетерсным свойством β-дефинициального равенства путей.
           Посмотрите на них, они тоже интересные! Эта же статья посвящена целиком CCHM верификатору гомотопической
           системы типов с двумя равенствами (известной также как HTS система Воеводского или
           система 2LTT Крауса и Анненкова). Также Андерс содержит в качестве примитива стек де Рама,
           что делает его пригодным для программирования когомологий и синтетической дифференциальной геометрии.
        </div></p>

        <figure><code>type exp =
  | EPre of Z.t | EKan of Z.t
  | EVar of name | EHole
  | EPi of exp * (name * exp) | ELam of exp * (name * exp) | EApp of exp * exp
  | ESig of exp * (name * exp) | EPair of tag * exp * exp
  | EFst of exp | ESnd of exp | EField of exp * string
  | EId of exp | ERef of exp | EJ of exp
  | EPathP of exp | EPLam of exp | EAppFormula of exp * exp
  | EI | EDir of dir | EAnd of exp * exp | EOr of exp * exp | ENeg of exp
  | ETransp of exp * exp | EHComp of exp * exp * exp * exp
  | EPartial of exp | EPartialP of exp * exp | ESystem of exp System.t
  | ESub of exp * exp * exp | EInc of exp * exp | EOuc of exp
  | EGlue of exp | EGlueElem of exp * exp * exp | EUnglue of exp
  | EEmpty | EIndEmpty of exp
  | EUnit | EStar | EIndUnit of exp
  | EBool | EFalse | ETrue | EIndBool of exp
  | EW of exp * (name * exp) | ESup of exp * exp | EIndW of exp * exp * exp
  | EIm of exp | EInf of exp | EIndIm of exp * exp | EJoin of exp
</code></figure>

        <h4>Космос или структура вселенных</h4>

<p>Начать статью хотим у стройства тайп чекера. В сущности своей тайп чекер это id функция (A -> A), где A -- это
пространство программ на языке выражений exp:</P>

<figure><code>type exp = | EPre of Z.t | EKan of Z.t | EVar of name | EHole </code></figure>

<p>Система HTS (или 2LTT) характеризуется наличием двух иерархий предикативных
   вселенных U<sub>i</sub> для фибрационных типов и V<sub>j</sub> для так претипов,
   где и живет гомотопический многомерный отрезок. Также в ядре тайп чекера обычно
   находятся конструкторы для переменных и дыр удобных для процесса извлечения доказательств.
  Уравнения для этих примитивов будет дано в этом параграфе.</p>

<p>Сам тайпчекер устроен таким образом (стандартная практика, см. например ставшие уже классическими
тайпчекеры Mini-TT или cubicaltt), что для процесса бета-нормализации (эвалуации) или интерпретирования
выражения используется внутреннее представление, оптимизированное для нужд эффективных
вычислений.</p>

<figure><code>type value = | VKan of Z.t | VPre of Z.t | Var of name * value | VHole</code></figure>

<p>Таким образом сигнатура тайпчекера выглядит так:</p>

<figure><code>and check ctx (e0 : exp) (t0 : value) = traceCheck e0 t0; try match e0, t0 with</code></figure>

<p>Алгоритм классический и звучит так: для типового выражения и его экземпляра мы берем экземпляр
типового выражения выводим его тип и сравниваем с заданым типовым выражением. Если они совпадают то все хорошо,
если нет -- то ошибка типизации. Дальше идет список паттерн-матчинг уравнений всех функций на деревьях
языковых выражений expr:</p>

<figure><code>check:
  | EHole, v -> traceHole v ctx
  | e, VPre u -> begin
    match infer ctx e with
    | VKan v | VPre v -> if ieq u v then () else raise (Ineq (VPre u, VPre v))
    | t -> raise (Ineq (VPre u, t)) end
  | e, t -> eqNf (infer ctx e) t
  
conv:
  | VKan u, VKan v -> ieq u v | VPre u, VPre v -> ieq u v
  | Var (u, _), Var (v, _) -> u = v

eval:
  | EPre u -> VPre u | EKan u -> VKan u
  | EVar x -> getRho ctx x | EHole -> VHole

infer:
  | VPre n -> VPre (Z.succ n) | VKan n -> VKan (Z.succ n)
  | EPre u -> VPre (Z.succ u) | EKan u -> VKan (Z.succ u)
  | EVar x -> lookup x ctx

inferV:
  | Var (_, t) -> t | VPre n -> VPre (Z.succ n) | VKan n -> VKan (Z.succ n)

act:
  | Var (i, VI) -> actVar rho i | Var (x, t) -> Var (x, act rho t) | VHole -> VHole
  | VKan u -> VKan u | VPre u -> VPre u

check:
  | e, t -> eqNf (infer ctx e) t
</code></figure>

<p>Здесь описывается так называемся база рекурсии и работа с контекстом верификатора (getRho, lookup).</p>

        <h4>Π-тип</h4>

<figure><code>eval:
  | EPi (a, (p, b)) -> let t = eval a ctx in VPi (t, (fresh p, closByVal ctx p t b))
  | ELam (a, (p, b)) -> let t = eval a ctx in VLam (t, (fresh p, closByVal ctx p t b))
  | EApp (f, x) -> app (eval f ctx, eval x ctx)

infer:
  | EPi (a, (p, b)) -> inferTele ctx p a b

inferV:
  | VPi (t, (x, f)) -> imax (inferV t) (inferV (f (Var (x, t))))
  | VLam (t, (x, f)) -> VPi (t, (x, fun x -> inferV (f x)))
  | VApp (f, x) -> begin match inferV f with
    | VPi (_, (_, g)) -> g x
    | v -> raise (ExpectedPi v) end

act:
  | VLam (t, (x, g)) -> VLam (act rho t, (x, g >> act rho))
  | VPi (t, (x, g)) -> VPi (act rho t, (x, g >> act rho))
  | VApp (f, x) -> app (act rho f, act rho x)

app:
  | f, x -> VApp (f, x)

conv:
  | VPi (a,(p,f)), VPi (b,(_,g)) -> let x = Var (p,a) in conv a b && conv (f x) (g x)
  | VLam (a,(p,f)), VLam (b,(_,g))
  | VApp (f,a), VApp (g,b) -> conv f g && conv a b
  
check:
  | ELam (a, (p, b)), VPi (t, (_, g)) ->
    ignore (extSet (infer ctx a)); eqNf (eval a ctx) t;
    let x = Var (p, t) in let ctx' = upLocal ctx p t x in check ctx' b (g x)

and inferTele ctx p a b =
    ignore (extSet (infer ctx a));
    let t = eval a ctx in let x = Var (p, t) in
    let ctx' = upLocal ctx p t x in
    let v = infer ctx' b in imax (infer ctx a) v
  
and inferLam ctx p a e =
    ignore (extSet (infer ctx a)); let t = eval a ctx in
    ignore (infer (upLocal ctx p t (Var (p, t))) e);
    VPi (t, (p, fun x -> inferV (eval e (upLocal ctx p t x))))
    
</code></figure>

<h4>Σ-тип</h4>

<figure><code>
infer:
  | ESig (a, (p, b)) -> inferTele ctx p a b
  | EFst e -> fst (extSigG (infer ctx e))
  | ESnd e -> let (_, (_, g)) = extSigG (infer ctx e) in g (vfst (eval e ctx))
  | EField (e, p) -> inferField ctx p e

inferV:
  | VFst e -> fst (extSigG (inferV e))
  | VSnd e -> let (_, (_, g)) = extSigG (inferV e) in g (vfst e)

eval:
  | ESig (a, (p, b)) -> let t = eval a ctx in VSig (t, (fresh p, closByVal ctx p t b))
  | EPair (r, e1, e2) -> VPair (r, eval e1 ctx, eval e2 ctx)
  | EFst e -> vfst (eval e ctx)
  | EField (e, p) -> evalField p (eval e ctx)

check:
  | EPair (r, e1, e2), VSig (t, (p, g)) ->
    ignore (extSet (inferV t)); check ctx e1 t;
    check ctx e2 (g (eval e1 ctx)); begin match p with
    | Name (v, _) -> r := Some v
    | Irrefutable -> () end

act:
  | VSig (t, (x, g)) -> VSig (act rho t, (x, g >> act rho))
  | VPair (r, u, v) -> VPair (r, act rho u, act rho v)
  | VFst k -> vfst (act rho k) | VSnd k -> vsnd (act rho k)

conv:
  | VFst x, VFst y | VSnd x, VSnd y -> conv x y
  | VPair (_, a, b), VPair (_, c, d) -> conv a c && conv b d
  | VPair (_, a, b), v | v, VPair (_, a, b) -> conv (vfst v) a && conv (vsnd v) b

and inferField ctx p e = snd (getField p (eval e ctx) (infer ctx e))

let rec getField p v = function
  | VSig (t, (q, g)) ->
    if matchIdent p q then (vfst v, t)
    else getField p (vsnd v) (g (vfst v))
  | t -> raise (ExpectedSig t)

let vfst : value -> value = function
  | VPair (_, u, _) -> u
  | v -> VFst v

let vsnd : value -> value = function
  | VPair (_, _, u) -> u
  | v -> VSnd v
</code></figure>

<h4>0-тип</h4>

<figure><code>eval:
  | EEmpty -> VEmpty
  | EIndEmpty e -> VIndEmpty (eval e ctx)

inferV:
  | VEmpty -> VKan Z.zero
  | VIndEmpty t -> implv VEmpty t

act:
  | VEmpty -> VEmpty
  | VIndEmpty v -> VIndEmpty (act rho v)

conv:
  | VEmpty, VEmpty -> true
  | VIndEmpty u, VIndEmpty v -> conv u v

infer:
  | EEmpty | EUnit
  | EIndEmpty e -> ignore (extSet (infer ctx e)); implv VEmpty (eval e ctx)
</code></figure>

<h4>1-тип</h4>

<figure><code>eval:
  | EUnit -> VUnit
  | EStar -> VStar
  | EIndUnit e -> VIndUnit (eval e ctx)

app:
  | VApp (VIndUnit _, x), VStar -> x

inferV:
  | VUnit -> VKan Z.zero
  | VStar -> VUnit
  | VIndUnit t -> recUnit t

act:
  | VUnit -> VUnit
  | VStar -> VStar
  | VIndUnit v -> VIndUnit (act rho v)

conv:
  | VUnit, VUnit -> true
  | VStar, VStar -> true
  | VIndUnit u, VIndUnit v -> conv u v

infer:
  | EStar -> VUnit
  | EIndUnit e -> inferInd false ctx VUnit e recUnit

and recUnit t = let x = freshName "x" in
  implv (app (t, VStar)) (VPi (VUnit, (x, fun x -> app (t, x))))
</code></figure>

<h4>2-тип</h4>

<figure><code>eval:
  | EBool -> VBool
  | EFalse -> VFalse
  | ETrue -> VTrue
  | EIndBool e -> VIndBool (eval e ctx)

app:
  | VApp (VApp (VIndBool _, a), _), VFalse -> a
  | VApp (VApp (VIndBool _, _), b), VTrue -> b

inferV:
  | VBool -> VKan Z.zero
  | VFalse | VTrue -> VBool
  | VIndBool t -> recBool t

act:
  | VBool -> VBool
  | VFalse -> VFalse
  | VTrue -> VTrue
  | VIndBool v -> VIndBool (act rho v)

conv:
  | VBool, VBool -> true
  | VFalse, VFalse -> true
  | VTrue, VTrue -> true
  | VIndBool u, VIndBool v -> conv u v

infer:
  | EBool -> VKan Z.zero
  | EFalse | ETrue -> VBool
  | EIndBool e -> inferInd false ctx VBool e recBool

and recBool t = let x = freshName "x" in
  implv (app (t, VFalse)) (implv (app (t, VTrue))
    (VPi (VBool, (x, fun x -> app (t, x)))))
</code></figure>

<h4>W-тип</h4>

<figure><code>
eval:
  | EW (a, (p, b)) -> let t = eval a ctx in W (t, (fresh p, closByVal ctx p t b))
  | ESup (a, b) -> VSup (eval a ctx, eval b ctx)
  | EIndW (a, b, c) -> VIndW (eval a ctx, eval b ctx, eval c ctx)

app: 
  | VApp (VIndW (a, b, c), g), VApp (VApp (VSup (_, _), x), f) ->
    app (app (app (g, x), f),
      VLam (app (b, x), (freshName "b", fun y ->
        app (VApp (VIndW (a, b, c), g), app (f, y)))))

inferV:
  | VSup (a, b) -> inferSup a b
  | VIndW (a, b, c) -> inferIndW a b c

and wtype a b = W (a, (freshName "x", fun x -> app (b, x)))

and inferSup a b = let t = wtype a b in let x = freshName "x" in
  VPi (a, (x, fun x -> implv (implv (app (b, x)) t) t))

and inferIndW a b c = let t = wtype a b in
  implv (VPi (a, (freshName "x", fun x ->
    VPi (implv (app (b, x)) t, (freshName "f", fun f ->
      implv (VPi (app (b, x), (freshName "b", fun b -> app (c, (app (f, b))))))
        (app (c, VApp (VApp (VSup (a, b), x), f))))))))
    (VPi (t, (freshName "w", fun w -> app (c, w))))

act:
  | W (t, (x, g)) -> W (act rho t, (x, g >> act rho))
  | VSup (a, b) -> VSup (act rho a, act rho b)
  | VIndW (a, b, c) -> VIndW (act rho a, act rho b, act rho c)

conv:
  | VSup (a1,b1), VSup (a2,b2) -> conv a1 a2 && conv b1 b2
  | VIndW (a1,b1,c1), VIndW (a2,b2,c2) -> conv a1 a2 && conv b1 b2 && conv c1 c2

infer:
  | ESup (a, b) -> let t = eval a ctx in ignore (extSet (infer ctx a));
    let (t', (p, g)) = extPiG (infer ctx b) in eqNf t t';
    ignore (extSet (g (Var (p, t))));
    inferSup t (eval b ctx)
  | EIndW (a, b, c) -> let t = eval a ctx in ignore (extSet (infer ctx a));
    let (t', (p, g)) = extPiG (infer ctx b) in
    eqNf t t'; ignore (extSet (g (Var (p, t))));
    let (w', (q, h)) = extPiG (infer ctx c) in
    eqNf (wtype t (eval b ctx)) w';
    ignore (extSet (h (Var (q, w'))));
    inferIndW t (eval b ctx) (eval c ctx)

and inferIndW a b c = let t = wtype a b in
    implv (VPi (a, (freshName "x", fun x ->
      VPi (implv (app (b, x)) t, (freshName "f", fun f ->
        implv (VPi (app (b, x), (freshName "b", fun b -> app (c, (app (f, b))))))
          (app (c, VApp (VApp (VSup (a, b), x), f))))))))
      (VPi (t, (freshName "w", fun w -> app (c, w))))

   </code></figure>

   <h4>I-претип</h4>

<figure><code>eval:
  | EI -> VI
  | EDir d -> VDir d
  | EAnd (e1, e2) -> evalAnd (eval e1 ctx) (eval e2 ctx)
  | EOr (e1, e2) -> evalOr (eval e1 ctx) (eval e2 ctx)
  | ENeg e -> negFormula (eval e ctx)

inferV:
  | VI -> VPre Z.zero
  | VDir _ | VOr _ | VAnd _ | VNeg _ -> VI

act:
  | VI -> VI
  | VDir d -> VDir d
  | VAnd (u, v) -> evalAnd (act rho u) (act rho v)
  | VOr (u, v) -> evalOr (act rho u) (act rho v)
  | VNeg u -> negFormula (act rho u)

conv:
  | VI, VI -> true
  | VDir u, VDir v -> u = v

infer:
  | EI -> VPre Z.zero | EDir _ -> VI | ENeg e -> check ctx e VI; VI
  | EOr (e1, e2) | EAnd (e1, e2) -> check ctx e1 VI; check ctx e2 VI; VI
</code></figure>

<h4>Id-тип</h4>

<figure><code>eval:
  | EId e -> VId (eval e ctx)
  | ERef e -> VRef (eval e ctx)
  | EJ e -> VJ (eval e ctx)

infer:
  | EId e -> let v = eval e ctx in implv v (implv v (VPre (extSet (infer ctx e))))
  | ERef e -> let v = eval e ctx in VApp (VApp (VId (infer ctx e)), v), v)
  | EJ e -> inferJ (eval e ctx) (infer ctx e)

app:
  | VApp (VApp (VApp (VApp (VJ _, _), _), f), _), VRef _ -> f

inferV:
  | VId v -> let n = extSet (inferV v) in implv v (implv v (VPre n))
  | VJ v -> inferJ v (inferV v)

act:
  | VId v -> VId (act rho v)
  | VRef v -> VRef (act rho v)
  | VJ v -> VJ (act rho v)

and inferJ v t =
  let x = freshName "x" in
  let y = freshName "y" in
  let pi = freshName "P" in
  let p = freshName "p" in
  let k = extSet t in
  let t = VPi (v, (x, fun x -> VPi (v, (y, fun y -> implv (idv v x y) (VPre k))))) in
  VPi (t, (pi, fun pi ->
    VPi (v, (x, fun x ->
      implv (app (app (app (pi, x), x), VRef x))
            (VPi (v, (y, fun y ->
              VPi (idv v x y, (p, fun p ->
                app (app (app (pi, x), y), p))))))))))
</code></figure>

<h4>Path-тип</h4>

<figure><code>eval:
  | EPathP e -> VPathP (eval e ctx)
  | EPLam e -> VPLam (eval e ctx)
  
check:
  | EPLam (ELam (EI, (i, e))), VApp (VApp (VPathP p, u0), u1) ->
    let v = Var (i, VI) in let ctx' = upLocal ctx i VI v in
    let v0 = eval e (upLocal ctx i VI vzero) in
    let v1 = eval e (upLocal ctx i VI vone) in
    check ctx' e (appFormula p v); eqNf v0 u0; eqNf v1 u1

inferV:
  | VPLam (VLam (VI, (_, g))) -> let t = VLam (VI, (freshName "ι", g >> inferV)) in
    VApp (VApp (VPathP (VPLam t), g vzero), g vone)
  | VAppFormula (f, x)       -> let (p, _, _) = extPathP (inferV f) in appFormula p x
  | VPathP p -> let (_, _, v) = freshDim () in let t = inferV (appFormula p v) in
    let v0 = appFormula p vzero in let v1 = appFormula p vone in implv v0 (implv v1 t)

act:
  | VPLam f -> VPLam (act rho f)
  | VPathP v -> VPathP (act rho v)
  | VAppFormula (f, x)   -> appFormula (act rho f) (act rho x)

conv:
  | VPLam f, VPLam g -> conv f g
  | VPLam f, v | v, VPLam f ->
    let (_, _, i) = freshDim () in conv (appFormula v i) (app (f, i))
  | VPathP a, VPathP b -> conv a b

infer:
  | EPathP p -> inferPath ctx p
  | EPLam (ELam (EI, (i, e))) ->
    let ctx' = upLocal ctx i VI (Var (i, VI)) in ignore (infer ctx' e);
    let g = fun j -> eval e (upLocal ctx i VI j) in
    let t = VLam (VI, (freshName "ι", g >> inferV)) in
    VApp (VApp (VPathP (VPLam t), g vzero), g vone)
  | EPLam _ -> raise (InferError e)
  | VAppFormula (f, x), VAppFormula (g, y) -> conv f g && conv x y

and inferPath ctx p =
  let (_, t0, t1) = extPathP (infer ctx p) in
  (* path cannot connect different universes,
     so if one endpoint is in U, then so other *)
  let k = extSet (inferV t0) in implv t0 (implv t1 (VKan k))

and appFormula v x = match v with
  | VPLam f -> app (f, x)
  | _       -> let (_, u0, u1) = extPathP (inferV v) in
    begin match x with
      | VDir Zero -> u0
      | VDir One  -> u1
      | i -> VAppFormula (v, i)
    end
</code></figure>

<h4>Частичные типы, кубические системы</h4>

<figure><code>eval:
  | EPartial e -> let (i, _, _) = freshDim () in
    VLam (VI, (i, fun r -> let ts = mkSystem (List.map (fun mu ->
      (mu, eval e (faceEnv mu ctx))) (solve r One)) in VPartialP (VSystem ts, r)))
  | EPartialP (t, r) -> VPartialP (eval t ctx, eval r ctx)
  | ESystem xs -> VSystem (evalSystem ctx xs)

app:
  | VSystem ts, x -> reduceSystem ts x

inferV:
  | VPartialP (VSystem ts, _) -> begin match System.choose_opt ts with
    | Some (_, t) -> VPre (extSet (inferV t))
    | None        -> VPre Z.zero end
  | VPartialP (t, _) -> inferV (inferV t)
  | VSystem ts -> VPartialP (VSystem (System.map inferV ts), getFormulaV ts)

infer:
  | EPartial e -> let n = extSet (infer ctx e) in implv VI (VPre n)
  | EPartialP (u, r0) ->
    check ctx r0 VI; let t = infer ctx u in begin match t with
    | VPartialP (ts, r) -> eqNf r (eval r0 ctx); inferV (inferV ts)
    | _ -> failwith "Expected partial function into universe" end
  | ESystem ts -> checkOverlapping ctx ts;
    VPartialP (VSystem (System.mapi (fun mu -> infer (faceEnv mu ctx)) ts),
           eval (getFormula ts) ctx)

and evalSystem ctx = bimap (getRho ctx) (fun beta t -> eval t (faceEnv beta ctx))

and faceEnv alpha ctx =
  Env.map (fun (p, t, v) ->
  if p = Local then (p, updTerm alpha t, updTerm alpha v) else (p, t, v)) ctx
  |> Env.fold (fun p dir -> Env.add p (Local, Value VI, Value (VDir dir))) alpha

let reduceSystem ts x =
  match System.find_opt eps ts with
  | Some v -> v
  | None   -> VApp (VSystem ts, x)
</code></figure>

<h4>Кубические подтипы</h4>

<figure><code>eval:
  | ESub (a, i, u) -> VSub (eval a ctx, eval i ctx, eval u ctx)
  | EInc (t, r) -> VInc (eval t ctx, eval r ctx)
  | EOuc e -> ouc (eval e ctx)

app:
  | VInc (t, r), v -> inc t r v

inferV:
  | VSub (t, _, _) -> VPre (extSet (inferV t))
  | VInc (t, i) -> inferInc t i
  | VOuc v -> begin match inferV v with
    | VSub (t, _, _) -> t
    | _ -> raise (ExpectedSubtypeV v)  end

infer:
  | ESub (a, i, u) -> let n = extSet (infer ctx a) in check ctx i VI;
    check ctx u (partialv (eval a ctx) (eval i ctx)); VPre n
  | EInc (e, r) -> ignore (extKan (infer ctx e)); check ctx r VI;
    inferInc (eval e ctx) (eval r ctx)
  | EOuc e -> begin match infer ctx e with
      | VSub (t, _, _) -> t
      | _ -> raise (ExpectedSubtype e) end

conv:
  | VInc (t1, r1), VInc (t2, r2) -> conv t1 t2 && conv r1 r2
  | VOuc u, VOuc v -> conv u v

and inc t r = function | VOuc v -> v | v -> VApp (VInc (t, r), v)
and ouc v = match v, inferV v with
  | _, VSub (_, VDir One, u) -> app (u, VRef vone)
  | VApp (VInc _, v), _ -> v
  | _, _ -> VOuc v
</code></figure>

<h4>Glue-тип</h4>

<figure><code>
conv:
  | VGlue v, VGlue u -> conv u v
  | VUnglue v, VUnglue u -> conv u v
  | VGlueElem (r1,u1,a1), VGlueElem (r2,u2,a2) ->
    conv r1 r2 && conv u1 u2 && conv a1 a2
  
app:
  | VApp (VGlue _, VDir One), u -> vfst (app (u, VRef vone))

act:
  | VGlue v -> VGlue (act rho v)
  | VGlueElem (r, u, a) -> VGlueElem (act rho r, act rho u, act rho a)
  | VUnglue v -> VUnglue (act rho v)

conv:
  | VGlue v, VGlue u -> conv u v
  | VUnglue v, VUnglue u -> conv u v
  | VGlueElem (r1, u1, a1), VGlueElem (r2, u2, a2) ->
    conv r1 r2 && conv u1 u2 && conv a1 a2

infer:
  | EGlue e -> ignore (extKan (infer ctx e)); inferGlue (eval e ctx)
  | EGlueElem (e, u0, a) ->
    check ctx e VI; let r = eval e ctx in let t = infer ctx a in
    check ctx u0 (partialv (equivPtSingl t) r); let u = eval u0 ctx in
    List.iter (fun mu -> let v = app (upd mu u, VRef vone) in
      let f = vfst (vfst (vsnd v)) in
      eqNf (eval a (faceEnv mu ctx)) (app (f, vsnd (vsnd v)))) (solve r One);
    inferGlueElem r u t
  | EUnglue e -> let (t, _, _) = extGlue (infer ctx e) in t

inferV:
  | VGlue t -> inferGlue t
  | VGlueElem (r, u, a) -> inferGlueElem r u (inferV a)
  | VUnglue v -> let (t, _, _) = extGlue (inferV v) in t

and fiber t1 t2 f y =
  VSig (t1, (freshName "a", fun x -> pathv (idp t2) y (app (f, x)))) (* right fiber *)

and isContr t = let x = freshName "x" in let y = freshName "y" in
  VSig (t, (x, fun x -> VPi (t, (y, fun y -> pathv (idp t) x y))))
  
and isEquiv t1 t2 f = VPi (t2, (freshName "b", isContr << fiber t1 t2 f))
and equiv t1 t2 = VSig (implv t1 t2, (freshName "f", isEquiv t1 t2))
and equivSingl t0 = VSig (inferV t0, (freshName "T", fun t -> equiv t t0))
and equivPtSingl t0 = VSig (inferV t0, (freshName "T", fun t -> prodv (equiv t t0) t))

and inferGlue t = let (r, _, _) = freshDim () in let k = inferV t in
  VPi (VI, (r, fun r -> implv (partialv (equivSingl t) r) k))

and inferGlueElem r u t =
  VApp (VApp (VGlue t, r),
        VSystem (walk (fun v -> VPair (ref None, vfst v, vfst (vsnd v))) r u))

</code></figure>

<h4>Стек де Рама</h4>

<figure><code>eval:
  | EIm e -> VIm (eval e ctx)
  | EInf e -> inf (eval e ctx)
  | EJoin e -> join (eval e ctx)
  | EIndIm (a, b) -> VIndIm (eval a ctx, eval b ctx)

act:
  | VIm t -> VIm (act rho t)
  | VInf v -> inf (act rho v)
  | VJoin v -> join (act rho v)
  | VIndIm (a, b) -> VIndIm (act rho a, act rho b)

inferV:
  | VIm t -> inferV t
  | VInf v -> VIm (inferV v)
  | VJoin v -> extIm (inferV v)
  | VIndIm (a, b) -> inferIndIm a b

infer:
  | EIm e -> let t = infer ctx e in ignore (extSet t); t
  | EInf e -> VIm (infer ctx e)
  | EJoin e -> let t = extIm (infer ctx e) in ignore (extIm t); t
  | EIndIm (a, b) -> ignore (extSet (infer ctx a)); let t = eval a ctx in
    let (c, (x, g)) = extPiG (infer ctx b) in eqNf (VIm t) c;
    ignore (extSet (g (Var (x, c)))); inferIndIm t (eval b ctx)

conv:
  | VIm u, VIm v -> conv u v
  | VInf u, VInf v -> conv u v
  | VJoin u, VJoin v -> conv u v
  | VIndIm (a1, b1), VIndIm (a2, b2) -> conv a1 a2 && conv b1 b2

app:
  | VApp (VIndIm _, f), VInf a -> app (f, a)

and join = function | VInf v -> v | v -> VJoin v
and inf = function | VJoin v -> v | v -> VInf v

</code></figure>

<h4>Операции Кана</h4>

<figure><code>
infer:
  | ETransp (p, i) -> inferTransport ctx p i
  | EHComp (e, i, u, u0) -> let t = eval e ctx in let r = eval i ctx in
    ignore (extKan (infer ctx e)); check ctx i VI;
    check ctx u (implv VI (partialv t r)); check ctx u0 t;
    List.iter (fun phi -> let ctx' = faceEnv phi ctx in
      eqNf (eval (hcompval u) ctx') (eval u0 ctx')) (solve r One); t

inferV:
  | VTransp (p, _) -> implv (appFormula p vzero) (appFormula p vone)
  | VHComp (t, _, _, _) -> t

conv:
  | VTransp (p, i), VTransp (q, j) -> conv p q && conv i j
  | VHComp (t1, r1, u1, v1), VHComp (t2, r2, u2, v2) ->
    conv t1 t2 && conv r1 r2 && conv u1 u2 && conv v1 v2

app:
  | VTransp (p, i), u0 -> transp p i u0

act:
  | VTransp (p, i)       -> VTransp (act rho p, act rho i)
  | VHComp (t, r, u, u0) -> hcomp (act rho t) (act rho r) (act rho u) (act rho u0)

and transp p phi u0 = match p with
  | VPLam (VLam (VI, (i, g))) -> transport i (g (Var (i, VI))) phi u0
  | _ -> VApp (VTransp (p, phi), u0)

and inferTransport ctx p i =
  check ctx i VI;
  let u0 = appFormulaE ctx p ezero in
  let u1 = appFormulaE ctx p eone in
  let (t, _, _) = extPathP (infer ctx p) in
  ignore (extKan (inferV (appFormula t (Var (freshName "ι", VI)))));
  let (j, e, v) = freshDim () in let ctx' = upLocal ctx j VI v in
  List.iter (fun phi -> let rho = faceEnv phi ctx' in
    eqNf (appFormulaE rho p ezero) (appFormulaE rho p e))
    (solve (eval i ctx) One);
  implv u0 u1

and transport i p phi u0 = match p, phi, u0 with
  | _, VDir One, _ -> u0
  | VKan _, _, _ -> u0
  | VEmpty, _, _ -> u0
  | VUnit, _, _ -> u0
  | VBool, _, _ -> u0
  | VPi (t, (_, b)), _, _ -> let x = fresh (name "x") in
    let j = freshName "ι" in let k = freshName "κ" in
    VLam (act0 i vone t, (x, fun x ->
      let v = transFill j (act0 i (VNeg (dim j)) t) phi x in
      transport k (swap i k (b (v (VNeg (dim k)))))
        phi (app (u0, v vone))))
  | VSig (t, (_, b)), _, _ ->
    let j = freshName "ι" in let k = freshName "κ" in
    let v1 = transFill j (swap i j t) phi (vfst u0) in
    let v2 = transport k (swap i k (b (v1 (dim k)))) phi (vsnd u0) in
    VPair (ref None, v1 vone, v2)
  | VApp (VApp (VPathP p, v), w), _, _ ->
    let j = freshName "ι" in let k = freshName "κ" in
    VPLam (VLam (VI, (j, fun j ->
      let uj = appFormula u0 j in let r = evalOr phi (evalOr j (negFormula j)) in
      comp (fun k -> appFormula (act0 i k p) j) r k
        (VSystem (unionSystem (border (solve phi One) uj)
                 (unionSystem (border (solve j Zero) (swap i k v))
                              (border (solve j One)  (swap i k w))))) uj)))
  | W (t, (x, b)), _, VApp (VApp (VSup _, a), f) ->
    let j = freshName "ι" in let k = freshName "κ" in
    let v1 = transFill j (swap i j t) phi a in
    let v2 = transport k (swap i k (implv (b (v1 (dim k))) (W (t, (x, b))))) phi f in
    let t' = act0 i vone t in
    VApp (VApp (VSup (t', VLam (t', (fresh x, b >> act0 i vone))), v1 vone), v2)
  | VIm t, _, VInf a -> inf (transport i t phi a)
  | _, _, _ -> VApp (VTransp (VPLam (VLam (VI, (i, fun j -> act0 i j p))), phi), u0)

and transFill i p phi u0 j = let (k, _, _) = freshDim () in
  transport k (act0 i (evalAnd (dim k) j) p) (evalOr phi (negFormula j)) u0

and hcomp t r u u0 = let i = freshName "ι" in kan t r i (app (u, dim i)) u0

and kan t r i u u0 = match t, r, u, u0 with
  | _, VDir One, _, _ -> app (act0 i vone u, VRef vone)
  | VPi (t, (x, b)), _, _, _ -> VLam (t, (fresh x, fun y -> kan (b y) r i
    (VSystem (walk (fun v -> app (v, y)) r u)) (app (u0, y))))
  | VSig (t, (_, b)), _, _, _ -> let k = freshName "κ" in
    let v1 = hfill t r k (VSystem (walk (vfst >> act0 i (dim k)) r u)) (vfst u0) in
    let v2 = comp (v1 >> b) r i (VSystem (walk vsnd r u)) (vsnd u0) in
    VPair (ref None, v1 vone, v2)
  | VApp (VApp (VPathP t, v), w), _, _, _ ->
    let j = freshName "ι" in
    VPLam (VLam (VI, (j, fun j ->
      kan (appFormula t j) (evalOr r (evalOr j (negFormula j))) i
          (VSystem (unionSystem (walk (flip appFormula j) r u)
                   (unionSystem (border (solve j One)  w)
                                (border (solve j Zero) v))))
          (appFormula u0 j))))
  | VIm t, _, VSystem u, VInf u0 when System.for_all (fun _ -> isInf) u ->
    VInf (kan t r i (VSystem (System.map extInf u)) u0)
  | _, _, _, _ -> VHComp (t, r, VLam (VI, (i, fun j ->
    VSystem (walk (act0 i j) r u))), u0)

and comp t r i u u0 = let j = freshName "ι" in
  kan (t vone) r i
      (VSystem (walk (transport j (t (evalOr (dim i) (dim j))) (dim i)) r u))
      (transport j (t (dim j)) vzero u0)

and hfill t r i u u0 j = let k = freshName "κ" in
  kan t (evalOr (negFormula j) r) k
    (VSystem (unionSystem (walk (act0 i (evalAnd (dim k) j)) r u)
      (border (solve j Zero) u0))) u0

</code></figure>

<p></p>

</section>
</main>
<footer>Namdak Tonpa <span class="heart">&nbsp;❤&nbsp;</span> 2009—2022</footer>
</body>
</html>