<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>2022-01-17</title>
    <link rel="stylesheet" href="https://n2o.dev/blank.css" />
    <link rel="stylesheet" href="../../journal.css" />
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>TOP</a>
    <a href='#'>2022-01-17</a>
</nav>
<main>
    <section>
        <h3>Anders Theorem Prover</h3>

        <h4>КОСМОС</h4>

<p>Начать статью хотим у стройства тайп чекера. В сущности своей тайп чекер это id функция (A -> A), где A -- это
пространство программ на языке выражений exp:</P>

<figure><code>type exp =
  | EPre of Z.t | EKan of Z.t (* cosmos *)
  | EVar of name | EHole (* variables *)</code></figure>

<p>Сам тайпчекер устроен таким образом (стандартная практика, см. например ставшие уже классическими
тайпчекеры Mini-TT или cubicaltt), что для процесса бета-нормализации (эвалуации) или интерпретирования
выражения используется оптимизационное внутреннее представление, оптимизированное для нужд эффективных
вычислений.</p>

<figure><code>type value =
  | VKan of Z.t | VPre of Z.t
  | Var of name * value | VHole</code></figure>

<p>Таким образом сигнатура тайпчекера выглядит так:</p>

<figure><code>and check ctx (e0 : exp) (t0 : value) = traceCheck e0 t0; try match e0, t0 with</code></figure>

<p>Дальше идет список паттерн-матчинг уравнений всех функций на деревьях языковых выражений expr.</p>

<figure><code>check:
  | EHole, v -> traceHole v ctx
  | e, VPre u -> begin
    match infer ctx e with
    | VKan v | VPre v -> if ieq u v then () else raise (Ineq (VPre u, VPre v))
    | t -> raise (Ineq (VPre u, t))
  | e, t -> eqNf (infer ctx e) t</code></figure>

<figure><code>conv:
  | VKan u, VKan v -> ieq u v
  | VPre u, VPre v -> ieq u v
  | Var (u, _), Var (v, _) -> u = v</code></figure>

<figure><code>eval:
  | EPre u -> VPre u
  | EKan u -> VKan u
  | EVar x -> getRho ctx x
  | EHole -> VHole</code></figure>

<figure><code>infer:
  | VPre n -> VPre (Z.succ n)
  | VKan n -> VKan (Z.succ n)
  | EPre u -> VPre (Z.succ u)
  | EKan u -> VKan (Z.succ u)
  | EVar x -> lookup x ctx</code></figure>

<figure><code>inferV:
  | Var (_, t) -> t
  | VPre n -> VPre (Z.succ n)
  | VKan n -> VKan (Z.succ n)</code></figure>

<figure><code>act:
  | Var (i, VI) -> actVar rho i
  | Var (x, t) -> Var (x, act rho t)
  | VHole -> VHole
  | VKan u -> VKan u
  | VPre u -> VPre u</code></figure>

<p>Здесь описывается так называемся база рекурсии и работа с контекстом прувера (getRho, lookup).</p>


