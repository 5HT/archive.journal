<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>2022-01-17</title>
    <link rel="stylesheet" href="https://n2o.dev/blank.css" />
    <link rel="stylesheet" href="../../journal.css" />
</head>
<body>
<nav>
    <a href='../../index.html'>5HT</a>
    <a href='../index.html'>TOP</a>
    <a href='#'>2022-01-17</a>
</nav>
<main>
    <section>
        <h3>Anders: верификатор математики</h3>

        <p>Верификатор математики Anders все лишь один из трех гомотопических пруверов Групоид Инфинити.
           Другие два &mdash; это: 1) верификатор под названием Hurricane системы типов HoTT-I,
           которая используется в теорем прувере JetBrains Arend, а также 2) верификатор
           под названием Castle Bravo авторской системы типов HoTT-∂. В отличии от Anders,
           обе системы HoTT-I и HoTT-∂ обладают инетерсным свойством β-дефинициального равенства путей.
           Посмотрите на них, они тоже интересные! Эта же статья посвящена целиком верификатору гомотопической
           системы типов с двумя равенствами (известной также как HTS система Воеводского или
           система 2LTT Крауса и Анненкова). Также Андерс содержит в качестве примитива стек де Рама,
           что делает его пригодным для программирования когомологий и синтетической дифференциальной геометрии.
        </div></p>

        <figure><code>type exp =
  | EPre of Z.t | EKan of Z.t
  | EVar of name | EHole
  | EPi of exp * (name * exp) | ELam of exp * (name * exp) | EApp of exp * exp
  | ESig of exp * (name * exp) | EPair of tag * exp * exp
  | EFst of exp | ESnd of exp | EField of exp * string
  | EId of exp | ERef of exp | EJ of exp
  | EPathP of exp | EPLam of exp | EAppFormula of exp * exp
  | EI | EDir of dir | EAnd of exp * exp | EOr of exp * exp | ENeg of exp
  | ETransp of exp * exp | EHComp of exp * exp * exp * exp
  | EPartial of exp | EPartialP of exp * exp | ESystem of exp System.t
  | ESub of exp * exp * exp | EInc of exp * exp | EOuc of exp
  | EGlue of exp | EGlueElem of exp * exp * exp | EUnglue of exp
  | EEmpty | EIndEmpty of exp
  | EUnit | EStar | EIndUnit of exp
  | EBool | EFalse | ETrue | EIndBool of exp
  | EW of exp * (name * exp) | ESup of exp * exp | EIndW of exp * exp * exp
  | EIm of exp | EInf of exp | EIndIm of exp * exp | EJoin of exp
</code></figure>

        <h4>КОСМОС</h4>

<p>Начать статью хотим у стройства тайп чекера. В сущности своей тайп чекер это id функция (A -> A), где A -- это
пространство программ на языке выражений exp:</P>

<figure><code>type exp = | EPre of Z.t | EKan of Z.t | EVar of name | EHole </code></figure>

<p>Сам тайпчекер устроен таким образом (стандартная практика, см. например ставшие уже классическими
тайпчекеры Mini-TT или cubicaltt), что для процесса бета-нормализации (эвалуации) или интерпретирования
выражения используется внутреннее представление, оптимизированное для нужд эффективных
вычислений.</p>

<figure><code>type value = | VKan of Z.t | VPre of Z.t | Var of name * value | VHole</code></figure>

<p>Таким образом сигнатура тайпчекера выглядит так:</p>

<figure><code>and check ctx (e0 : exp) (t0 : value) = traceCheck e0 t0; try match e0, t0 with</code></figure>

<p>Алгоритм классический и звучит так: для типового выражения и его экземпляра мы берем экземпляр
типового выражения выводим его тип и сравниваем с заданым типовым выражением. Если они совпадают то все хорошо,
если нет -- то ошибка типизации. Дальше идет список паттерн-матчинг уравнений всех функций на деревьях
языковых выражений expr:</p>

<figure><code>check:
  | EHole, v -> traceHole v ctx
  | e, VPre u -> begin
    match infer ctx e with
    | VKan v | VPre v -> if ieq u v then () else raise (Ineq (VPre u, VPre v))
    | t -> raise (Ineq (VPre u, t))
  | e, t -> eqNf (infer ctx e) t</code></figure>

<figure><code>conv:
  | VKan u, VKan v -> ieq u v | VPre u, VPre v -> ieq u v
  | Var (u, _), Var (v, _) -> u = v</code></figure>

<figure><code>eval:
  | EPre u -> VPre u | EKan u -> VKan u
  | EVar x -> getRho ctx x | EHole -> VHole</code></figure>

<figure><code>infer:
  | VPre n -> VPre (Z.succ n) | VKan n -> VKan (Z.succ n)
  | EPre u -> VPre (Z.succ u) | EKan u -> VKan (Z.succ u)
  | EVar x -> lookup x ctx</code></figure>

<figure><code>inferV:
  | Var (_, t) -> t | VPre n -> VPre (Z.succ n) | VKan n -> VKan (Z.succ n)</code></figure>

<figure><code>act:
  | Var (i, VI) -> actVar rho i | Var (x, t) -> Var (x, act rho t) | VHole -> VHole
  | VKan u -> VKan u | VPre u -> VPre u</code></figure>

<p>Здесь описывается так называемся база рекурсии и работа с контекстом верификатора (getRho, lookup).</p>

        <h4>Π-тип</h4>

<figure><code>eval:
  | EPi (a, (p, b)) -> let t = eval a ctx in VPi (t, (fresh p, closByVal ctx p t b))
  | ELam (a, (p, b)) -> let t = eval a ctx in VLam (t, (fresh p, closByVal ctx p t b))
  | EApp (f, x) -> app (eval f ctx, eval x ctx)
</code></figure>

<p></p>


